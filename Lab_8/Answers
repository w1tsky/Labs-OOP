1. Что такое обобщение?
    Обобщение - это параметризированный тип.(Механизм многократного использования алгоритмов.)
2. Пусть дан фрагмент листинга.В какой строчке содержится  ошибка?

    class Gen<T,G>//1
    {
      G ob;//2
      T bo;//3
      public Gen(G o){ob=o;}//4
      public T GetOb() {return bo;}//5
    }
    
  4?
3. Как можно наложить определённое ограничение на параметр?

    Ограничения на параметр можно наложить с помощью ключевого слова where
    Пример: public static T Min<T>(T o1, T o2) where T: IComparable<T>{}
    
4. Как можно наложить несколько ограничений на параметр ?

    С параметром типа может быть связано несколько ограничений. В этом случае ограничения указываются списоком через запятую.
    Пример:
    class SomeClass{}
    interface Interface1{}
    class GenericClass<T,U> where T: SomeClass, Interface1
                            where U: new()
                            {}
5. Перечислите все существующие ограничения на типы данных обобщения?

    where T: базовый класс// Ограничение базового класса
    where T: интерфейс // ограничение интерфейса
    where T: class // ограничение ссылочного типа
    where T: struct //ограничение типа значения (исключая типы, допускающие null )
    where T: new() // ограничение конструктора без параметров
    where U:T // неприкрытое ограничение типа

6. Какое ограничение на тип задано в следующем фрагменте листинга?

    class A 
    { }
    class В : A 
    { }
    class С { }
    class Test<T> where T : A { }
   Ответ:Ограничение на базовый класс.
 
 7. Какое ограничение на тип задано в следующем фрагменте листинга? 

  interface A 
  { }
  class Test<T> where T : class { }
  
  Ответ : Ограничение ссылочного типа.
 
8. Какое ограничение на тип задано в следующем фрагменте листинга? 
    interface A
    { } 
    class Test<T> where T : struct { }
Ответ: Ограничение типа значения.

9. Приведите примеры, когда обобщенный класс может действовать как базовый или производный класс.

Обобщенные классы могут входить в иерархию классов аналогично необобщенным классам. Следовательно, обобщенный класс может действовать
как базовый или производный класс. Главное отличие между иерархиями обобщенных и необобщенных классов заключается в том, что в первом 
случае аргументы типа, необходимые обобщенному базовому классу, должны передаваться всеми производными классами вверх по иерархии 
аналогично передаче аргументов конструктора. В производном классе следует непременно указывать параметры типа, требующиеся его
обобщенному базовому классу, даже если этот производный класс не обязательно должен быть обобщенным. Разумеется, в производный класс 
можно свободно добавлять его собственные параметры типа, если в этом есть потребность.

  //Простая иерархия обобщенных классов. using System;
  //Обобщенный базовый класс.
  class Gen<T> { 
    Т ob;
    public Gen(T о) { ob = о;}
    // Возвратить значение переменной ob.
    public Т GetOb() {
    return ob;
    }
  }
  // Класс, производный от класса Gen.
  class Gen2<T> : Gen<T> {
    public Gen2(T o) : base(o) { // ...}
  }
  class GenHierDemo { 
    static void Main()
    {
     Gen2<string> g2 = new Gen2<string>("Привет"); Console.WriteLine(g2.GetOb());
    }
  }
  
//Пример необобщенного класса в качестве базового для обобщенного производного класса.
using System;
// Необобщенный базовый класс.
class NonGen {
int num;
public NonGen(int i) 
{
num = i;
}
public int GetNum() 
{
return num;
}
}
// Обобщенный производный класс.
class Gen<T> : NonGen
{
T ob;
public Gen(T о, int i) : base (i)
{ 
ob = o;
}
// Возвратить значение переменной ob. public T GetOb() {
return ob;
}
}

// Создать объект класса Gen. 
class HierDemo3 {
static void Main() {
// Создать объект класса Gen с параметром типа string. 
Gen<String> w = new Gen<String>("Привет", 47);
Console.Write(w.GetOb() + " "); Console.WriteLine(w.GetNum());
}
}
10. В каких случаях в обобщениях может использоваться оператор default ?

Ключевое слово default может применяться для получения стандартного значения обобщенного параметра типа. стандартным значением для
ссылочного типа является null, а для типа значения - результат побитового обнуления полей в этом типе:
static void Zap<T>( T[] array )
{
for(int i=0); i<array.Length;i++)
array[i]=default(T);
}

11. Поясните как использовать статические переменные в обобщенных классах.

При типизации обобщенного класса определенным типом будет создаваться свой набор статических членов. Например, в классе Account
определено следующее статическое поле:
class Account<T>
{
    public static T session; 
    public T Id { get; set; }
    public int Sum { get; set; }
}
Теперь типизируем класс двумя типами int и string:
Account<int> account1 = new Account<int> { Sum = 5000 };
Account<int>.session = 5436;
Account<string> account2 = new Account<string> { Sum = 4000 };
Account<string>.session = "45245";
Console.WriteLine(Account<int>.session);      // 5436
Console.WriteLine(Account<string>.session);   // 45245
В итоге для Account<string> и для Account<int> будет создана своя переменная session.

12. Приведите пример обобщенного интерфейса.

// Объявляем обобщенный интерфейс
    public interface ISort<T> 
        where T : struct
    {
        void ReWrite();
    }
    
13. В чём отличие обобщённых классов от обобщённых структур?
Обобщенные структуры в отличии от обобщенных классов не могут наследоваться.

14. Какие классы для работы с файлами вы знаете? Приведите пример.

Классы File и FileInfo. Класс FileStream. Классы StreamReader и StreamWriter. Работа с бинарными файлами- классы BinaryWriter и 
BinaryReader Создание и чтение сжатых файлов - классы GZipStream и DeflateStream.
string path = @"C:\apache\hta.txt";
FileInfo fileInf = new FileInfo(path);
if (fileInf.Exists)
{
   fileInf.Delete();
   // альтернатива с помощью класса File
   // File.Delete(path);
}
